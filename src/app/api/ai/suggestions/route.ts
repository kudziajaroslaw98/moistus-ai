import type { AppEdge } from '@/types/app-edge';
import type { AppNode } from '@/types/app-node';
import type { SuggestionContext } from '@/types/ghost-node';
import { google } from '@ai-sdk/google';
import { streamObject } from 'ai';
import { z } from 'zod';

// Zod schema for suggestion validation
const suggestionSchema = z.object({
	suggestions: z
		.array(
			z
				.object({
					id: z
						.string()
						.describe(
							'A unique identifier for the suggestion, typically in UUID format.'
						),

					content: z
						.string()
						.describe('The main text content or label for the suggested node.'),

					nodeType: z
						.enum([
							'defaultNode',
							'textNode',
							'imageNode',
							'resourceNode',
							'questionNode',
							'annotationNode',
							'codeNode',
							'taskNode',
							'builderNode',
						] as const)
						.describe(
							'The type of node being suggested. Must be one of the specified values.'
						),

					confidence: z
						.number()
						.min(0)
						.max(1)
						.describe(
							"A score from 0.0 to 1.0 indicating the AI's confidence in this suggestion."
						),

					position: z
						.object({
							x: z
								.number()
								.describe(
									'The suggested horizontal (x-axis) coordinate for the new node on the canvas.'
								),
							y: z
								.number()
								.describe(
									'The suggested vertical (y-axis) coordinate for the new node on the canvas.'
								),
						})
						.describe(
							'The initial x and y coordinates for placing the suggested node on the mind map canvas.'
						),

					context: z
						.object({
							sourceNodeId: z
								.string()
								.nullable()
								.describe(
									"The ID of the node that this suggestion originates from, if any. Null if it's a general map suggestion."
								),

							targetNodeId: z
								.string()
								.nullable()
								.describe(
									'The ID of a target node if the suggestion is for a connection between two nodes. Often null for new node suggestions.'
								),

							relationshipType: z
								.string()
								.nullable()
								.describe(
									"Describes the proposed relationship between the source and the new node (e.g., 'expands on', 'is an example of')."
								),

							trigger: z
								.enum(['magic-wand', 'dangling-edge', 'auto'])
								.describe(
									'The type of user action or system event that triggered this suggestion.'
								),
						})
						.describe(
							'Information about what triggered the suggestion and its relationship to existing nodes.'
						),

					reasoning: z
						.string()
						.nullable()
						.describe(
							'A brief, user-facing explanation for why this suggestion is being made.'
						),
				})
				.describe(
					'A single, actionable suggestion for a new node to be added to the mind map.'
				)
		)
		.describe('An array of node suggestions generated by the AI.'),
});

const suggestionObjectSchema = z
	.object({
		id: z
			.string()
			.describe(
				'A unique identifier for the suggestion, typically in UUID format.'
			),

		content: z
			.string()
			.describe('The main text content or label for the suggested node.'),

		nodeType: z
			.enum([
				'defaultNode',
				'textNode',
				'imageNode',
				'resourceNode',
				'questionNode',
				'annotationNode',
				'codeNode',
				'taskNode',
				'builderNode',
			] as const)
			.describe(
				'The type of node being suggested. Must be one of the specified values.'
			),

		confidence: z
			.number()
			.min(0)
			.max(1)
			.describe(
				"A score from 0.0 to 1.0 indicating the AI's confidence in this suggestion."
			),

		position: z
			.object({
				x: z
					.number()
					.describe(
						'The suggested horizontal (x-axis) coordinate for the new node on the canvas.'
					),
				y: z
					.number()
					.describe(
						'The suggested vertical (y-axis) coordinate for the new node on the canvas.'
					),
			})
			.describe(
				'The initial x and y coordinates for placing the suggested node on the mind map canvas.'
			),

		context: z
			.object({
				sourceNodeId: z
					.string()
					.nullable()
					.describe(
						"The ID of the node that this suggestion originates from, if any. Null if it's a general map suggestion."
					),

				targetNodeId: z
					.string()
					.nullable()
					.describe(
						'The ID of a target node if the suggestion is for a connection between two nodes. Often null for new node suggestions.'
					),

				relationshipType: z
					.string()
					.nullable()
					.describe(
						"Describes the proposed relationship between the source and the new node (e.g., 'expands on', 'is an example of')."
					),

				trigger: z
					.enum(['magic-wand', 'dangling-edge', 'auto'])
					.describe(
						'The type of user action or system event that triggered this suggestion.'
					),
			})
			.describe(
				'Information about what triggered the suggestion and its relationship to existing nodes.'
			),

		reasoning: z
			.string()
			.nullable()
			.describe(
				'A brief, user-facing explanation for why this suggestion is being made.'
			),
	})
	.describe(
		'A single, actionable suggestion for a new node to be added to the mind map.'
	);

// Set maximum duration for the API route
export const maxDuration = 30;

export async function POST(request: Request) {
	try {
		const { nodes, edges, mapId, context } = await request.json();

		// Validate required fields
		if (!nodes || !Array.isArray(nodes)) {
			return Response.json({ error: 'Invalid nodes data' }, { status: 400 });
		}

		if (!edges || !Array.isArray(edges)) {
			return Response.json({ error: 'Invalid edges data' }, { status: 400 });
		}

		if (!mapId || typeof mapId !== 'string') {
			return Response.json({ error: 'Invalid mapId' }, { status: 400 });
		}

		if (!context || !context.trigger) {
			return Response.json({ error: 'Invalid context data' }, { status: 400 });
		}

		// Build suggestion context
		const suggestionContext = buildSuggestionContext(nodes, edges, context);

		// Generate suggestions using AI
		const result = streamObject({
			model: google('gemini-2.5-flash'),
			output: 'array',
			schema: suggestionObjectSchema,
			// model: openai('o4-mini', {
			// 	structuredOutputs: true,
			// }),
			// experimental_output: Output.object({
			// }),
			// providerOptions: {
			// 	google: {
			// 		thinkingConfig: {
			// 			thinkingBudget: 1000,
			// 		},
			// 	},
			// },
			messages: [
				{
					role: 'system',
					content: SUGGESTION_PROMPT,
				},
				{
					role: 'user',
					content: `
		            Here is the current mind map context:
		            ${suggestionContext}

		            Based on this context, suggest 1-4 relevant nodes that would enhance this mind map.
		            Consider the trigger type: ${context.trigger}
		            ${context.sourceNodeId ? `Source node ID: ${context.sourceNodeId}` : ''}
		            ${context.targetNodeId ? `Target node ID: ${context.targetNodeId}` : ''}
		            ${context.relationshipType ? `Relationship type: ${context.relationshipType}` : ''}

		          `,
				},
			],
		});

		return result.toTextStreamResponse();

		/*
		const { object } = await generateObject({
			model: google('gemini-2.5-flash'),
			schema: suggestionSchema,
			providerOptions: {
				google: {
					thinkingConfig: {
						thinkingBudget: 1000,
					},
				},
			},
			messages: [
				{
					role: 'system',
					content: SUGGESTION_PROMPT,
				},
				{
					role: 'user',
					content: `
		            Here is the current mind map context:
		            ${suggestionContext}

		            Based on this context, suggest 1-3 relevant nodes that would enhance this mind map.
		            Consider the trigger type: ${context.trigger}
		            ${context.sourceNodeId ? `Source node ID: ${context.sourceNodeId}` : ''}
		            ${context.targetNodeId ? `Target node ID: ${context.targetNodeId}` : ''}
		            ${context.relationshipType ? `Relationship type: ${context.relationshipType}` : ''}
		          `,
				},
			],
		});
	 */
	} catch (error) {
		console.error('Error generating suggestions:', error);

		return Response.json(
			{
				error: 'Failed to generate suggestions',
				details: error instanceof Error ? error.message : 'Unknown error',
			},
			{ status: 500 }
		);
	}
}

// Context Analysis Engine
function buildSuggestionContext(
	nodes: AppNode[],
	edges: AppEdge[],
	context: SuggestionContext
): string {
	const relevantNodes = getRelevantNodes(nodes, edges, context);
	const relevantEdges = getRelevantEdges(edges, context);

	let contextString = '';

	// Add node information
	if (relevantNodes.length > 0) {
		contextString += 'Relevant Nodes:\n';
		relevantNodes.forEach((node, index) => {
			contextString += `${index + 1}. ${node.data.content || 'Untitled'} (Type: ${node.data.node_type || 'default'})\n`;

			// Add metadata if available
			if (node.data.metadata) {
				if (node.data.metadata.title) {
					contextString += `   Title: ${node.data.metadata.title}\n`;
				}

				if (node.data.metadata.summary) {
					contextString += `   Summary: ${node.data.metadata.summary}\n`;
				}

				if (node.data.tags && node.data.tags.length > 0) {
					contextString += `   Tags: ${node.data.tags.join(', ')}\n`;
				}
			}

			contextString += '\n';
		});
	}

	// Add edge information
	if (relevantEdges.length > 0) {
		contextString += 'Relevant Connections:\n';
		relevantEdges.forEach((edge, index) => {
			const sourceNode = nodes.find((n) => n.id === edge.source);
			const targetNode = nodes.find((n) => n.id === edge.target);

			contextString += `${index + 1}. ${sourceNode?.data.content || 'Unknown'} â†’ ${targetNode?.data.content || 'Unknown'}`;

			if (edge.data?.label) {
				contextString += ` (${edge.data.label})`;
			}

			contextString += '\n';
		});
		contextString += '\n';
	}

	// Add context-specific information
	if (context.sourceNodeId) {
		const sourceNode = nodes.find((n) => n.id === context.sourceNodeId);

		if (sourceNode) {
			contextString += `Focus Node: ${sourceNode.data.content || 'Untitled'}\n`;
			contextString += `Focus Node Type: ${sourceNode.data.node_type || 'default'}\n\n`;
		}
	}

	return contextString;
}

/**
 * Identifies and returns the most relevant nodes for building suggestion context
 * @param nodes - Array of all nodes in the mind map
 * @param edges - Array of all edges representing connections between nodes
 * @param context - Suggestion context containing trigger information and source node
 * @returns Array of relevant nodes, limited to 5 for optimal context building
 *
 * Logic:
 * - If sourceNodeId is provided: Returns the source node plus its connected neighbors
 * - If no sourceNodeId: Returns the most recent 5 nodes as general context
 * - Connected nodes are found by traversing edges to build meaningful relationships
 */
function getRelevantNodes(
	nodes: AppNode[],
	edges: AppEdge[],
	context: SuggestionContext
): AppNode[] {
	if (context.sourceNodeId) {
		// Get the source node and its immediate neighbors
		const sourceNode = nodes.find((n) => n.id === context.sourceNodeId);

		if (sourceNode) {
			return [
				sourceNode,
				...getConnectedNodes(nodes, edges, context.sourceNodeId),
			].slice(0, 5);
		}
	}

	// If no specific source, return recent or important nodes
	return nodes.slice(-5); // Last 5 nodes as context
}

function getRelevantEdges(
	edges: AppEdge[],
	context: SuggestionContext
): AppEdge[] {
	if (context.sourceNodeId) {
		// Get edges connected to the source node
		return edges.filter(
			(e) =>
				e.source === context.sourceNodeId || e.target === context.sourceNodeId
		);
	}

	return edges.slice(-5); // Last 5 edges as context
}

/**
 * Finds all nodes connected to the given nodeId via edges
 * @param nodes - Array of all nodes in the graph
 * @param edges - Array of all edges representing connections between nodes
 * @param nodeId - The ID of the node to find connections for
 * @returns Array of connected nodes (deduplicated)
 */
function getConnectedNodes(
	nodes: AppNode[],
	edges: AppEdge[],
	nodeId: string
): AppNode[] {
	// Validate inputs
	if (!nodeId || !edges || !nodes) {
		return [];
	}

	// Find all edges connected to the given nodeId (both incoming and outgoing)
	const connectedEdges = edges.filter(
		(edge) => edge.source === nodeId || edge.target === nodeId
	);

	// Get the connected node IDs and deduplicate using Set
	const connectedNodeIds = new Set(
		connectedEdges.map((edge) =>
			edge.source === nodeId ? edge.target : edge.source
		)
	);

	// Filter the nodes array to get the connected nodes
	return nodes.filter((node) => connectedNodeIds.has(node.id));
}

// Prompt Engineering
const SUGGESTION_PROMPT = `
You are an expert at expanding mind maps with relevant, insightful nodes. Your task is to suggest 1-3 new nodes that would meaningfully enhance the given mind map.

Guidelines for suggestions:
1. **Relevance**: Ensure suggestions are directly related to the existing content and context
2. **Diversity**: Suggest different types of nodes (text, questions, resources, etc.) when appropriate
3. **Depth**: Add nodes that deepen understanding or explore new angles
4. **Practical Value**: Focus on actionable, useful, or thought-provoking content
5. **Natural Flow**: Suggestions should feel like a natural extension of the current thinking

Node Type Selection:
- **textNode**: For explanatory content, definitions, or detailed information
- **questionNode**: For thought-provoking questions or areas to explore
- **resourceNode**: For external links, books, tools, or references
- **taskNode**: For actionable items or next steps
- **codeNode**: For technical examples, snippets, or implementations
- **imageNode**: When visual content would enhance understanding
- **annotationNode**: For comments, notes, or additional context
- **defaultNode**: For general concepts or simple nodes

Confidence Scoring:
- 0.8-1.0: High confidence - directly relevant and valuable
- 0.6-0.8: Medium confidence - somewhat relevant but speculative
- 0.4-0.6: Low confidence - tangentially related or experimental

Return structured JSON with array containing objects with id, content, nodeType, confidence, position, context, and reasoning fields.
`;
